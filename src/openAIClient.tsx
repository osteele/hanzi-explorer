export type CompletionParameters = {
  model: string;
  prompt: string | string[];
  frequencyPenalty?: number;
  maxTokens?: number;
  numResults?: number;
  presencePenalty?: number;
  temperature?: number;
};

export type CompletionParameterSetters = {
  setPrompt: (prompt: string) => void;
  setModel: (model: string) => void;
  setFrequencyPenalty: (frequencyPenalty: number) => void;
  setMaxTokens: (maxTokens: number) => void;
  setNumResults: (numResults: number) => void;
  setPresencePenalty: (presencePenalty: number) => void;
  setTemperature: (temperature: number) => void;
  // [Property in keyof CompletionParameters as `set${Capitalize<string & Property>}`]: (Type[Property]) => void;
};

function modelIsChatModel(model: string): boolean {
  return model.startsWith("gpt-");
}

export type Completions = {
  prompt: string;
  completion: string;
  isChat: boolean;
}[];

type GetCompletionsProps = {
  apiKey: string;
  onProgress?: (choices: Completions) => void;
} & CompletionParameters;

/**
 * This function retrieves completions for a given prompt from OpenAI's API.
 * @param {GetCompletionsProps} props - Object containing the parameters
 *          required to retrieve completions from OpenAI's API.
 * @returns {Promise<{ data: { choices: Completions } }>} An object containing a
 *          Promise that resolves to an array of choices generated by the API.
 */
export async function getCompletions(
  props: GetCompletionsProps & { signal: AbortSignal }
): Promise<{ data: { choices: Completions } }> {
  const { apiKey, onProgress, signal, ...modelParameters } = props;

  // If the prompt is an array, apply streamingCompletion to each prompt,
  // combine the results into one array of choices, and return a Promise
  // for this array
  const { numResults, prompt } = { numResults: 1, ...modelParameters };
  if (Array.isArray(prompt)) {
    const choices = Array.from({ length: numResults * prompt.length }, () => ({
      prompt: "",
      completion: "",
      isChat: false,
    }));
    // Call getCompletions recursively to retrieve completions for each
    // individual prompt in the array
    await Promise.all(
      prompt.map((prompt, i) =>
        getCompletions({
          ...modelParameters,
          apiKey,
          prompt,
          signal,
          onProgress: (choicesSlice) => {
            choices.splice(i * numResults, numResults, ...choicesSlice);
            onProgress?.(choices);
          },
        })
      )
    );
    return {
      data: {
        choices,
      },
    };
  }

  // Decide which endpoint to use depending on whether the model is a chat model
  // or not
  const isChatModel = modelIsChatModel(modelParameters.model);
  const endpoint = isChatModel ? "chat/completions" : "completions";

  // Prepare model parameters as required by the endpoint (i.e., add messages
  // object for chat models)
  const preparedModelParameters = isChatModel
    ? {
        messages: [
          {
            role: "user",
            content: prompt,
          },
        ],
        ...modelParameters,
        prompt: undefined,
      }
    : modelParameters;

  // If debug mode is enabled, log the request prompt
  if (process.env.DEBUG) {
    console.debug("requesting", prompt);
  }

  // Send the request to OpenAI's API with required headers and data
  const response = await fetch(`https://api.openai.com/v1/${endpoint}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      stream: true,
      ...renameModelParameterNames(preparedModelParameters),
    }),
    signal,
  });

  // Handle errors by parsing the error message provided by the API
  if (response.status >= 400) {
    const text = await response.text();
    let e = new Error(text);
    try {
      const json = JSON.parse(text);
      e = json.error;
    } catch {}
    throw e;
  }

  // Read response as a readable stream of newline-separated values, and process
  // incoming data
  const reader = response.body
    ?.pipeThrough(new TextDecoderStream())
    .getReader();
  if (!reader) {
    throw new Error("Internal error: failed to create TextDecoderStream");
  }

  // Initialize choices array
  const choices = Array.from({ length: numResults }, () => ({
    prompt,
    completion: "",
    isChat: isChatModel,
  }));

  // Process incoming data line-by-line until the "DONE" message is received
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    if (
      value.split("\n").some((line) => {
        if (line === "data: [DONE]") {
          // Stop processing when the "DONE" message is received
          return true;
        } else if (line.startsWith("data: ")) {
          // Process each incoming message
          const data = JSON.parse(line.slice(6));
          for (const choice of data.choices) {
            // Concatenate completion text to previous completions
            const index = choice.index;
            choices[index].completion +=
              choice.text ?? choice.delta.content ?? "";
          }
          onProgress?.(choices);
        }
        return false;
      })
    ) {
      break;
    }
  }

  reader.releaseLock(); // not in a `finally`; but isn't strictly necessary anyway
  return { data: { choices } };
}

export class CompletionRequestManager {
  private pendingControllers: AbortController[] = [];

  public async getCompletions(
    props: GetCompletionsProps
  ): Promise<{ data: { choices: Completions } }> {
    const controller = new AbortController();
    const signal = controller.signal;
    try {
      this.pendingControllers.push(controller);
      return await getCompletions({ ...props, signal });
    } finally {
      const ix = this.pendingControllers.indexOf(controller);
      if (ix >= 0) {
        this.pendingControllers.splice(ix, 1);
      }
    }
  }

  public async cancelAllPendingRequests(): Promise<void> {
    for (const controller of this.pendingControllers) {
      controller.abort();
    }
  }
}

/**
 * Renames keys in an object according to specified rules.
 *
 * @param parameters - The object whose keys should be renamed.
 * @returns A new object with renamed keys based on the original keys and values
 *          from the input object.
 *
 * @example
 * const parameters = { maxResults: 10, pageToken: "abc123", numResults: 5 };
 * const renamedParams = renameModelParameterNames(parameters);
 * // renamedParams == { max_results: 10, page_token: "abc123", n: 5 }
 */
function renameModelParameterNames(parameters: { [key: string]: any }): {
  [key: string]: any;
} {
  const result: { [key: string]: any } = {};

  for (const [key, value] of Object.entries(parameters)) {
    if (key === "numResults") {
      result["n"] = value;
    } else {
      const snakeCase = camelToSnakeCase(key);
      result[snakeCase] = value;
    }
  }

  return result;
}

// A utility function to convert a string from camelCase to snake_case.
function camelToSnakeCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
